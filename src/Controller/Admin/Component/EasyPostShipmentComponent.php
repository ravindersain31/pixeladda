<?php

namespace App\Controller\Admin\Component;

use App\Constant\Editor\Addons;
use App\Entity\Order;
use App\Entity\OrderShipment;
use App\Enum\OrderShipmentTypeEnum;
use App\Enum\OrderStatusEnum;
use App\Enum\ShippingEnum;
use App\Enum\ShippingStatusEnum;
use App\Event\OrderShippedEvent;
use App\Form\Admin\Order\CreateParcelsType;
use App\Form\Admin\Order\CustomsFormType;
use App\Helper\UploaderHelper;
use App\Helper\VichS3Helper;
use App\Service\Admin\AutoGeneratedProofService;
use App\Service\EasyPost\EasyPost;
use App\Service\EasyPost\EasyPostAddress;
use App\Service\EasyPost\PreferredShipping;
use App\Service\OrderLogger;
use Doctrine\ORM\EntityManagerInterface;
use Dompdf\Dompdf;
use Dompdf\Options;
use iio\libmergepdf\Merger;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Form\FormInterface;
use Symfony\Component\HttpFoundation\Response;
use Symfony\UX\LiveComponent\Attribute\AsLiveComponent;
use Symfony\UX\LiveComponent\Attribute\LiveAction;
use Symfony\UX\LiveComponent\Attribute\LiveArg;
use Symfony\UX\LiveComponent\Attribute\LiveProp;
use Symfony\UX\LiveComponent\ComponentToolsTrait;
use Symfony\UX\LiveComponent\DefaultActionTrait;
use Symfony\UX\LiveComponent\LiveCollectionTrait;

#[AsLiveComponent(
    name: "EasyPostShipmentComponent",
    template: "admin/components/order/ep-shipment/index.html.twig"
)]
class EasyPostShipmentComponent extends AbstractController
{
    use DefaultActionTrait;
    use LiveCollectionTrait;
    use ComponentToolsTrait;

    #[LiveProp(writable: true)]
    public ?Order $order = null;

    #[LiveProp(writable: true)]
    public OrderShipmentTypeEnum $type = OrderShipmentTypeEnum::DELIVERY;

    #[LiveProp(writable: true)]
    public ?string $shippingRateId = null;

    public function __construct(
        private readonly EntityManagerInterface   $entityManager,
        private readonly OrderLogger              $orderLogger,
        private readonly EasyPostAddress          $easyPostAddress,
        private readonly EasyPost                 $easyPost,
        private readonly EventDispatcherInterface $eventDispatcher,
        private readonly PreferredShipping        $preferredShipping,
        private readonly UploaderHelper           $uploaderHelper,
        private readonly Addons                   $addons,
        private readonly VichS3Helper             $s3Helper,
        private readonly AutoGeneratedProofService      $autoGeneratedProofService
    ) {}

    protected function instantiateForm(): FormInterface
    {
        $orderShipments = $this->order->getOrderShipments();
        $firstShipment = $orderShipments->first();
        if ($firstShipment && is_null($this->shippingRateId)) {
            $shippingRates = $this->preferredShipping->get($firstShipment->getRates(), $this->order);
            $this->shippingRateId = $shippingRates['selectedRate'];
        }

        if ($this->order->isCustomsPending()) {
            return $this->createForm(CustomsFormType::class);
        }
        return $this->createForm(CreateParcelsType::class, null, ['order' => $this->order]);
    }

    #[LiveAction]
    public function createCustomInfo(): void
    {
        $this->submitForm();
        $form = $this->getForm();
        if ($form->isSubmitted() && $form->isValid()) {
            $data = $form->getData();
            $eelPfc = $data['eelPfc'];
            if (empty($eelPfc)) {
                $data['eelPfc'] = 'NOEEI 30.37(a)';
            }
            $this->order->setCustomsForm($data);
            $this->entityManager->persist($this->order);
            $this->entityManager->flush();

            $this->orderLogger->setOrder($this->order);
            $this->orderLogger->log('Customs information saved successfully.', $this->getUser());

            $this->resetForm();

            $newForm = $this->instantiateForm();
            $this->form = $newForm;
            $this->formName = $newForm->getName();
            $this->formView = $newForm->createView();

            $this->entityManager->refresh($this->order);
        }
    }

    #[LiveAction]
    public function removeCustomsForm(): void
    {
        $shipments = $this->order->getOrderShipments()->count();
        if ($shipments > 0) {
            $this->addFlash('danger', 'Customs information can\'t be removed because parcels are already created. Please delete the parcels first.');
            return;
        }

        $this->order->setCustomsForm([]);
        $this->entityManager->persist($this->order);
        $this->entityManager->flush();

        $this->orderLogger->setOrder($this->order);
        $this->orderLogger->log('Customs information removed successfully.', $this->getUser());

        $this->entityManager->refresh($this->order);
        $this->resetForm();
    }

    #[LiveAction]
    public function createParcel(): void
    {
        $this->submitForm();
        $form = $this->getForm();
        if ($form->isSubmitted() && $form->isValid()) {
            $parcels = $form->get('parcels')->getData();
            $this->createParcels($parcels);
        } else {
            $this->addFlash('danger', 'Parcel data is invalid. Please check the form and try again.');
        }
    }

    public function createParcels(array $parcels): void
    {
        $numberOfBatchExists = $this->entityManager->getRepository(OrderShipment::class)->getMaxBatchNumber($this->order, $this->type);

        $epShippingAddress = $this->order->getMetaDataKey('epShippingAddress');
        $this->easyPost->setToAddressId($epShippingAddress['id']);
        $this->easyPost->setType($this->type);

        if ($this->type === OrderShipmentTypeEnum::RETURN) {
            if ($this->order->hasTag('BLIND_SHIPPING')) {
                $this->easyPost->setFromAddressId($this->easyPost->getBlindAddressId());
            } else {
                $this->easyPost->setFromAddressId($this->easyPost->getReturnAddressId());
            }
        } else {
            if ($this->order->hasTag('BLIND_SHIPPING')) {
                $this->easyPost->setReturnAddressId($this->easyPost->getBlindAddressId());
            }

            $epFromAddress = $this->order->getMetaDataKey('epFromAddress');
            if ($epFromAddress && isset($epFromAddress['id'])) {
                $this->easyPost->setReturnAddressId($epFromAddress['id']);
            }
        }

        $response = $this->easyPost->create($parcels, $this->order);

        if ($response['success']) {
            $this->order->setShippingMethod(ShippingEnum::EASYPOST);
            $this->order->setShippingOrderId($response['shippingId']);

            $shipments = $this->mapParcelData($response['shipments'], $response['parcels']);

            $batchNum = $numberOfBatchExists + 1;
            foreach ($shipments as $shipment) {
                $this->createOrderShipment($shipment, $response['shippingId'], $batchNum);
            }
            $this->resetForm();

            if ($this->type === OrderShipmentTypeEnum::DELIVERY) {
                $this->order->setShippingStatus(ShippingStatusEnum::SHIPMENT_CREATED);
            }
            $this->order->setUpdatedAt(new \DateTimeImmutable());
            $this->entityManager->persist($this->order);
            $this->entityManager->flush();
            $this->entityManager->refresh($this->order);
            $this->orderShipmentBatches($this->type);

            $orderShipments = $this->order->getOrderShipments();
            $firstShipment = $orderShipments->first();
            if ($firstShipment && is_null($this->shippingRateId)) {
                $shippingRates = $this->preferredShipping->get($firstShipment->getRates(), $this->order);
                $this->shippingRateId = $shippingRates['selectedRate'];
            }
        } else {
            $this->addFlash('danger', $response['message']);
        }
    }

    #[LiveAction]
    public function buyLabel(#[LiveArg] int $batch): void
    {
        $orderShipmentsOfBatch = $this->entityManager->getRepository(OrderShipment::class)->shipmentInBatchOfOrder($this->order, $batch, $this->type);

        if (count($orderShipmentsOfBatch) > 0) {
            $firstShipmentOfBatch = $orderShipmentsOfBatch[0];
            $filteredRates = array_filter($firstShipmentOfBatch->getRates(), fn($rate) => $rate['id'] === $this->shippingRateId);
            $rate = !empty($filteredRates) ? reset($filteredRates) : null;
            if (!$rate) {
                $this->addFlash('danger', 'Please select the shipping service to buy a label.');
                return;
            }

            $response = $this->easyPost->buy($firstShipmentOfBatch->getShipmentOrderId(), $rate);
            if (!$response['success']) {
                $this->addFlash('danger', $response['message']);
                return;
            }

            if (isset($response['order'])) {
                foreach ($orderShipmentsOfBatch as $orderShipment) {
                    $filteredShipments = array_filter($response['order']['shipments'], fn($shipment) => $shipment['id'] === $orderShipment->getShipmentId());
                    $shipment = !empty($filteredShipments) ? reset($filteredShipments) : null;
                    if ($shipment) {
                        $this->saveLabelInShipment($orderShipment, $shipment);
                    }
                }
            } else {
                $this->saveLabelInShipment($firstShipmentOfBatch, $response['shipment']);
            }

            if ($this->type === OrderShipmentTypeEnum::DELIVERY) {
                $this->order->setShippingStatus(ShippingStatusEnum::LABEL_PURCHASED);
            }

            $this->order->setUpdatedAt(new \DateTimeImmutable());

            $pdfLabelKey = $this->type === OrderShipmentTypeEnum::DELIVERY ? 'postageLabelAllPdf' : 'postageReturnLabelAllPdf';
            $this->order->setMetaDataKey($pdfLabelKey, null);
            $this->entityManager->persist($this->order);
            $this->addFlash('success', 'Label purchased successfully.');
            $this->entityManager->flush();
        }
        $this->entityManager->refresh($this->order);
        $this->resetForm();
    }

    #[LiveAction]
    public function validateAddress(#[LiveArg] bool $verify): void
    {
        $address = $this->easyPostAddress;

        $shippingAddress = $this->order->getShippingAddress();
        $address->setName($shippingAddress['firstName'] . ' ' . $shippingAddress['lastName']);
        $address->setStreet1($shippingAddress['addressLine1']);
        $address->setStreet2($shippingAddress['addressLine2']);
        $address->setCity($shippingAddress['city']);
        $address->setState($shippingAddress['state']);
        $address->setZip($shippingAddress['zipcode']);
        $address->setCountry($shippingAddress['country']);
        $address->setPhone($shippingAddress['phone']);
        $address->setResidential(true);

        $response = $address->create($verify);
        if ($response['success']) {
            if ($this->type === OrderShipmentTypeEnum::DELIVERY) {
                $this->order->setShippingStatus(ShippingStatusEnum::READY_FOR_SHIPMENT);
            }
            $this->order->setMetaDataKey('epShippingAddress', $response['address']);
            $this->entityManager->persist($this->order);
            $this->entityManager->flush();
        } else {
            $this->addFlash('danger', $response['message']);
            $this->addFlash('info', 'Please update the shipping address on the order overview page. You can access it by clicking the "View" button above.');
        }

        $this->entityManager->refresh($this->order);
    }

    #[LiveAction]
    public function deleteParcelforce(#[LiveArg] int $id): void
    {
        $orderShipment = $this->entityManager->getRepository(OrderShipment::class)->find($id);
        $this->entityManager->remove($orderShipment);
        $this->entityManager->flush();
        $this->entityManager->refresh($this->order);
    }

    #[LiveAction]
    public function shippedItemSelector(#[LiveArg] int $shipment, #[LiveArg] ?string $itemType = null): void
    {
        $orderShipment = $this->entityManager->getRepository(OrderShipment::class)->find($shipment);
        $orderShipment->setMetaDataKey('shippedItemType', $itemType);
        $this->entityManager->persist($orderShipment);
        $this->entityManager->flush();
        $this->addFlash('success', 'Shipped item type updated successfully.');
        $this->entityManager->refresh($this->order);
    }

    #[LiveAction]
    public function deleteParcels(#[LiveArg] int $batch): void
    {
        $orderShipmentsOfBatch = $this->entityManager->getRepository(OrderShipment::class)->shipmentInBatchOfOrder($this->order, $batch, $this->type);

        if (count($orderShipmentsOfBatch) === 0) {
            $this->addFlash('danger', 'No parcels found.');
            return;
        }

        foreach ($orderShipmentsOfBatch as $orderShipment) {
            if ($orderShipment->getTrackingId()) {
                $this->addFlash('danger', 'Parcels can\'t be deleted because they are associated with label. Refresh the page and refund the parcels instead.');
                return;
            }
            $this->entityManager->remove($orderShipment);
        }
        if ($batch === 1) {
            $this->order->setShippingOrderId(null);
        }
        if ($this->type === OrderShipmentTypeEnum::DELIVERY) {
            $this->order->setShippingMethod(ShippingEnum::EASYPOST);
            $this->order->setShippingStatus(ShippingStatusEnum::READY_FOR_SHIPMENT);
        }
        $this->entityManager->persist($this->order);
        $this->entityManager->flush();
        $this->addFlash('success', 'Parcels deleted successfully.');
        $this->entityManager->refresh($this->order);
        $this->shippingRateId = null;
    }

    #[LiveAction]
    public function refundParcels(#[LiveArg] int $batch): void
    {
        $orderShipmentsOfBatch = $this->entityManager->getRepository(OrderShipment::class)->shipmentInBatchOfOrder($this->order, $batch, $this->type);

        if (count($orderShipmentsOfBatch) === 0) {
            $this->addFlash('danger', 'No Shipments found. batch: ' . $batch);
            return;
        }

        $refundedShipments = [];
        foreach ($orderShipmentsOfBatch as $orderShipment) {
//            if (!in_array($orderShipment->getStatus(), ['unknown', 'pending'])) {
//                continue;
//            }
            $response = $this->easyPost->refund($orderShipment->getShipmentId());
            if ($response['success']) {
                $refund = $response['refund'];
                $orderShipment->setStatus($refund['status']);
                $orderShipment->setRefundedAt(new \DateTimeImmutable());
                $orderShipment->setRefundStatus($refund['refund_status']);
                $orderShipment->setRefundMeta($refund);

                if ($this->type === OrderShipmentTypeEnum::DELIVERY) {
                    $this->order->setShippingStatus(ShippingStatusEnum::READY_FOR_SHIPMENT);
                }
                $this->entityManager->persist($orderShipment);
                $refundedShipments[] = $orderShipment->getShipmentId();
            } else {
                $trackingId = $orderShipment->getTrackingId();
                $this->addFlash('danger', $trackingId . ': ' . $response['message']);
            }
        }

        if (!empty($refundedShipments)) {
            $this->addFlash('success', 'Parcels refunded successfully.');

            $pdfLabelKey = $this->type === OrderShipmentTypeEnum::DELIVERY ? 'postageLabelAllPdf' : 'postageReturnLabelAllPdf';
            $this->order->setMetaDataKey($pdfLabelKey, null);
            $this->entityManager->persist($this->order);
            $this->entityManager->flush();
        }

        $this->entityManager->refresh($this->order);
    }

    #[LiveAction]
    public function reloadRates(#[LiveArg] int $batch): void
    {
        $orderShipmentsOfBatch = $this->entityManager->getRepository(OrderShipment::class)->shipmentInBatchOfOrder($this->order, $batch, $this->type);
        if (count($orderShipmentsOfBatch) > 0) {
            $firstShipmentOfBatch = $orderShipmentsOfBatch[0];
            $response = $this->easyPost->getRates($firstShipmentOfBatch->getShipmentOrderId());
            if ($response['success']) {
                foreach ($orderShipmentsOfBatch as $orderShipment) {
                    $orderShipment->setRates($response['rates']);
                    $this->entityManager->persist($orderShipment);
                }
                $this->entityManager->flush();
            } else {
                $this->addFlash('danger', $response['message']);
            }
        }
        $this->entityManager->refresh($this->order);
    }

    #[LiveAction]
    public function markShipped(): Response
    {
        $this->order->setShippingStatus(ShippingStatusEnum::SHIPPED);
        $this->order->setStatus(OrderStatusEnum::SHIPPED);
        $this->order->setShippingDate($this->order->getDeliveryDate() ?? new \DateTimeImmutable());
        $this->order->setUpdatedAt(new \DateTimeImmutable());
        $shippingCost = self::getEasyPostShipmentCost($this->order) ?? 0;
        $this->order->setShippingCost($shippingCost);
        $this->order->setCompanyShippingCost($shippingCost);
        $this->entityManager->persist($this->order);
        $this->entityManager->flush();


        $message = 'Order ID: <b>' . $this->order->getOrderId() . '</b> has been shipped successfully.';
        $this->orderLogger->setOrder($this->order);
        $this->orderLogger->log($message, $this->getUser());
        $this->addFlash('success', $message);

        $event = new OrderShippedEvent($this->order);
        $this->eventDispatcher->dispatch($event, OrderShippedEvent::NAME);

        return $this->redirect($this->generateUrl('admin_warehouse_queue_ready_to_print'));
    }

    #[LiveAction]
    public function printSingleLabel(#[LiveArg] int $shipment): void
    {
        $orderShipment = $this->entityManager->getRepository(OrderShipment::class)->find($shipment);

        $postageLabel = $orderShipment->getPostageLabel();
        if (!$postageLabel['label_url']) {
            $this->addFlash('error', 'Postage label is not available');
        }

        $user = $this->getUser();
        $this->orderLogger->setOrder($orderShipment->getOrder());

        $isReprinted = true;
        if (!$orderShipment->getPrintedAt()) {
            $orderShipment->setPrintedAt(new \DateTimeImmutable());
            $orderShipment->setPrintedBy($user);
            $isReprinted = false;
        }

        $this->entityManager->persist($orderShipment);
        $this->entityManager->flush();

        $message = 'Shipping Label is printed for Tracking ID: ' . $orderShipment->getTrackingId();
        if ($isReprinted) {
            $message = 'Shipping Label is reprinted for Tracking ID: ' . $orderShipment->getTrackingId();
        }
        $this->orderLogger->log($message);

        $postageLabel = $orderShipment->getPostageLabel();

        $this->entityManager->refresh($this->order);

        $this->dispatchBrowserEvent('open:url:new-tab', [
            'url' => $postageLabel['label_url'],
        ]);
    }

    #[LiveAction]
    public function printAllLabelInPDF(#[LiveArg] bool $reprint = false): void
    {
        $pdfLabelKey = $this->type === OrderShipmentTypeEnum::DELIVERY ? 'postageLabelAllPdf' : 'postageReturnLabelAllPdf';
        $postageLabelPDFUrl = $this->order->getMetaDataKey($pdfLabelKey);

        $this->updatePrintedBy();

        if ($postageLabelPDFUrl && !$reprint) {
            $this->dispatchBrowserEvent('open:url:new-tab', [
                'url' => $postageLabelPDFUrl,
            ]);
            return;
        }

        ini_set('memory_limit', '512M');
        ini_set('max_execution_time', 5000);

        $dompdf = new Dompdf();

        $option = new Options();
        $option->set('isHtml5ParserEnabled', true);
        $option->set('isRemoteEnabled', true);
        $option->set('isPhpEnabled', true);

        $dompdf->setOptions($option);

        $orderShipments = $this->entityManager->getRepository(OrderShipment::class)->findBy([
            'order' => $this->order,
            'type' => $this->type,
            'refundedAt' => null,
        ]);

        $html = '<style>@page { margin: 0; padding: 0; }</style>';

        foreach ($orderShipments as $shipment) {
            $postageLabel = $shipment->getPostageLabel();
            if (!empty($postageLabel['label_url'])) {
                $image = $postageLabel['label_url'];
                $imageSize = getimagesize($image);
                $width = $imageSize[0];
                $height = $imageSize[1];

                $dpi = 150;
                $widthInInches = $width / $dpi;
                $heightInInches = $height / $dpi;

                $dompdf->setPaper([0, 0, $widthInInches * 72, $heightInInches * 72]); // Set custom page size

                $html .= "<div style='page-break-after: always; margin: 0; padding: 0; text-align: center;'>";
                $html .= "<img src=\"$image\" style=\"width: auto;height: 100%\" alt=\"Label\">";
                $html .= "</div>";

                $shipment->setPrintedAt(new \DateTimeImmutable());
                $shipment->setPrintedBy($this->getUser());
                $this->entityManager->persist($shipment);
            }
        }


        $dompdf->loadHtml($html);

        $dompdf->render();

        $labelsPdfContent = $dompdf->output(); 

        $merger = new Merger();

        $approvedProof = $this->order->getApprovedProof();

        if ($this->order->isNeedProof() === false && $approvedProof === null) {
            $pdfBinary = $this->autoGeneratedProofService->generatePdf(order: $this->order, withCustomerDesign: true);
            $merger->addRaw($pdfBinary);
        } else {
            $approvedProof = $this->order->getApprovedProof();

            if ($approvedProof && $approvedProof->getFiles()) {
                foreach ($approvedProof->getFiles() as $file) {
                    if ($file->getType() === 'PROOF_FILE') {
                        $pdfUrl = $this->s3Helper->asset($file, 'fileObject');
                        $merger->addRaw(file_get_contents($pdfUrl));
                    }
                }
            }
        }

        $merger->addRaw($labelsPdfContent);

        $finalPdfContent = $merger->merge();

        $fileName = $this->order->getOrderId() . '-labels.pdf';
        $uploadedFile = $this->uploaderHelper->createFileFromContents($finalPdfContent, $fileName, 'application/pdf');
        $this->uploaderHelper->setUploadPath('easypost/labels/' . $this->order->getOrderId());
        $publicUrl = $this->uploaderHelper->upload($uploadedFile);

        $this->order->setMetaDataKey($pdfLabelKey, $publicUrl);
        $this->entityManager->persist($this->order);
        $this->entityManager->flush();

        $this->entityManager->refresh($this->order);

        $this->orderLogger->setOrder($this->order);
        $message = 'Shipping Labels are printed in PDF, Link: <a href="' . $publicUrl . '" target="_blank">Download PDF</a>';
        $this->orderLogger->log($message);

        $this->dispatchBrowserEvent('open:url:new-tab', [
            'url' => $publicUrl,
        ]);
    }

    #[LiveAction]
    public function createAllReturnBoxesAsDelivery(): void
    {
        $deliveryShipments = $this->entityManager->getRepository(OrderShipment::class)->findBy([
            'order' => $this->order,
            'type' => OrderShipmentTypeEnum::DELIVERY,
            'refundedAt' => null,
        ]);

        $parcels = [];

        foreach ($deliveryShipments as $shipment) {
            $parcel = $shipment->getMetaDataKey('parcel');
            $parcels[] = $parcel['original'];
        }

        $this->createParcels($parcels);
    }

    private function createOrderShipment(array $shipment, string $shipmentOrderId, int $batchNum): void
    {
        $orderShipment = new OrderShipment();
        $orderShipment->setOrder($this->order);
        $orderShipment->setBatchNum($batchNum);
        $orderShipment->setShipmentId($shipment['id']);
        $orderShipment->setFromAddressId($shipment['from_address']);
        $orderShipment->setToAddressId($shipment['to_address']);
        $orderShipment->setShipmentOrderId($shipmentOrderId);
        $orderShipment->setType($this->type);

        $orderShipment->setParcelId($shipment['parcel']['created']['id']);
        if (isset($shipment['parcel']['original']['internalNotes'])) {
            $orderShipment->setInternalNotes($shipment['parcel']['original']['internalNotes']);
        }

        if (isset($shipment['rates']) && $shipment['rates']) {
            $orderShipment->setRates($shipment['rates']);
            unset($shipment['rates']);
        }
        $orderShipment->setStatus($shipment['status']);

        $orderShipment->setMetaData($shipment);
        $orderShipment->setUpdatedAt(new \DateTimeImmutable());
        $this->entityManager->persist($orderShipment);
        $this->entityManager->flush();
    }

    private function saveLabelInShipment(OrderShipment $orderShipment, array $shipment): void
    {
        $selectedRate = $shipment['selected_rate'];
        $orderShipment->setCarrier($selectedRate['carrier'] ?? null);
        $orderShipment->setService($selectedRate['service'] ?? null);
        $orderShipment->setTrackingId($shipment['tracking_code']);
        $orderShipment->setSelectedRate($shipment['selected_rate']);
        $orderShipment->setPostageLabel($shipment['postage_label']);
        if (isset($shipment['rates']) && $shipment['rates']) {
            $orderShipment->setRates($shipment['rates']);
            unset($shipment['rates']);
        }
        $orderShipment->setStatus($shipment['status']);

        unset($shipment['selected_rate']);
        unset($shipment['postage_label']);
        unset($shipment['parcel']);
        $orderShipment->setMetaData([
            ...$orderShipment->getMetaData(),
            ...$shipment,
        ]);
        $orderShipment->setUpdatedAt(new \DateTimeImmutable());
        $orderShipment->setPurchasedAt(new \DateTimeImmutable());
        $orderShipment->setPurchasedBy($this->getUser());
        $this->entityManager->persist($orderShipment);
    }

    private function mapParcelData(array $shipments, array $parcels): array
    {
        foreach ($shipments as $key => $shipment) {
            $shipmentParcel = $shipment['parcel'];
            foreach ($parcels as $parcel) {
                if ($shipmentParcel['id'] === $parcel['created']['id']) {
                    $shipments[$key]['parcel'] = $parcel;
                }
            }
        }
        return $shipments;
    }

    private function getEasyPostShipmentCost(Order $order): float
    {
        $orderShipment = $this->entityManager->getRepository(OrderShipment::class)->findOneBy([
            'order' => $order,
            'shipmentOrderId' => $order->getShippingOrderId(),
        ]);

        if (!$orderShipment) {
            return 0;
        }

        $selectedRate = $orderShipment->getSelectedRate();
        $shipmentCost = $selectedRate['rate'] ?? 0;
        return (float) $shipmentCost;
    }

    private function updatePrintedBy(): void
    {
        $orderShipments = $this->entityManager->getRepository(OrderShipment::class)->findBy([
            'order' => $this->order,
            'type' => $this->type,
            'refundedAt' => null,
        ]);

        foreach ($orderShipments as $orderShipment) {
            if ($orderShipment->getPrintedBy()) {
                continue;
            }
            $orderShipment->setPrintedBy($this->getUser());
            $this->entityManager->persist($orderShipment);
        }
        $this->entityManager->flush();
        $this->entityManager->refresh($this->order);
    }

    public function orderShipmentBatches($type): array
    {
        return $this->entityManager->getRepository(OrderShipment::class)->findShipmentsGroupedByBatch($this->order, $type);
    }
}
