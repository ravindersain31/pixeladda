<?php

namespace App\Controller\Web;

use App\Entity\Admin\WarehouseShipByList;
use App\Entity\Category;
use App\Entity\Order;
use App\Entity\OrderShipment;
use App\Entity\OrderTransaction;
use App\Entity\Product;
use App\Entity\ProductType;
use App\Entity\Reports\DailyCogsReport;
use App\Entity\Reports\MonthlyCogsReport;
use App\Entity\Store;
use App\Entity\User;
use App\Enum\StoreConfigEnum;
use App\Enum\Ups\UpsServiceLevel;
use App\Helper\ImageHelper;
use App\Helper\PriceChartHelper;
use App\Helper\ShippingChartHelper;
use App\Helper\UploaderHelper;
use App\Repository\OrderRepository;
use App\Repository\OrderShipmentRepository;
use App\Repository\ProductRepository;
use App\Repository\ProofTemplateRepository;
use App\Repository\StoreRepository;
use App\Service\OrderDeliveryDateService;
use App\Service\StoreInfoService;
use App\Service\Ups\TimeInTransitPayload;
use App\Service\Ups\UpsServiceFilter;
use App\Service\Ups\UpsTimeInTransitService;
use App\Trait\StoreTrait;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bridge\Doctrine\Attribute\MapEntity;
use Symfony\Bridge\Twig\Mime\TemplatedEmail;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\KernelInterface;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\Address;
use Symfony\Component\Routing\Annotation\Route;
use App\Entity\AppUser;
use App\Entity\WholeSeller;
use App\Service\Admin\AutoGeneratedProofService;
use App\Service\VirtualProductService;

class DefaultController extends AbstractController
{
    use StoreTrait;

    public function __construct(
        private readonly StoreInfoService $storeInfoService,
        private readonly EntityManagerInterface $em

    ) {}

    #[Route('/', name: 'homepage')]
    public function index(VirtualProductService $virtualProductService): Response
    {
        $blocks['custom'] = [
            'title' => 'Choose Your Size',
            'isCustom' => true,
            'linkToCategory' => 'custom-signs',
            'products' => $virtualProductService->makeVirtualProduct(),
        ];

        return $this->render('default/index.html.twig', [
            'blocks' => $blocks
        ]);
    }

    #[Route('/shipment/track/', name: 'shipment_track')]
    public function shipmentTrack(Request $request, OrderRepository $orderRepository, OrderShipmentRepository $shipmentRepository): Response
    {
        $trackingId = $request->query->get('trk');
        $filter = [];
        if ($trackingId) {
            $filter['trackingId'] = $trackingId;
        }

        $orderId = $request->query->get('oid');
        if ($orderId) {
            $order = $orderRepository->findByOrderId($orderId);
            $filter['order'] = $order;
        }

        $shipment = $shipmentRepository->findOneBy($filter);
        if (!$shipment) {
            throw $this->createNotFoundException('Shipment not found');
        }

        return $this->render('default/shipment-tracking.html.twig', [
            'shipment' => $shipment,
            'order' => $shipment->getOrder(),
            'byOrderOnly' => $orderId && count($filter) === 1,
        ]);
    }

    #[Route('/test-image', name: 'test-image')]
    public function testImage(ImageHelper $imageHelper, UploaderHelper $uploaderHelper, KernelInterface $kernel): Response
    {
        $baseDirectory = $kernel->getProjectDir();
        $converted = $imageHelper->toPng($baseDirectory . '/assets/sample/sample.eps');
        if ($converted['success']) {
            $file = $uploaderHelper->createFileFromContents($converted['blob'], 'image.png');
            return new Response($converted['blob'], 200, [
                'Content-Type' => $converted['mimeType'],
            ]);
        }
        return $this->json($converted);
    }

    #[Route('/test-email', name: 'test-email')]
    public function testEMail(Request $request, EntityManagerInterface $entityManager, MailerInterface $mailer): Response
    {
        $user = $entityManager->getRepository(User::class)->findOneBy([], ['id' => 'DESC']);
        $order = $entityManager->getRepository(Order::class)->findOneBy(['orderId' => '2506474240'], ['id' => 'DESC']);
        $transaction = $entityManager->getRepository(OrderTransaction::class)->findOneBy([], ['refundedAmount' => 'DESC']);
        $month = $entityManager->getRepository(MonthlyCogsReport::class)->findOneBy(['date' => new \DateTimeImmutable('2024-06-01')]);
        $dailyCogsReports = $entityManager->getRepository(DailyCogsReport::class)->findBy(['month' => $month], ['date' => 'ASC']);
        $cart = $order->getCart();

        $emailAddress = $request->get('email', 'manoj@geekybones.com');
        $template = $request->get('template', 'admin/order/auto-generated-proof/index.html.twig');
        $storeName = $this->storeInfoService->getStoreName();
        $params = [
            'month' => $month,
            'dailyCogsReports' => $dailyCogsReports,
            'user' => $user,
            'userType' => 'admin',
            'order' => $order,
            'cart' => $cart,
            'message' => $order->getOrderMessages()->last(),
            'amount' => 10,
            'cartItem' => $cart->getCartItems()->first(),
            'transaction' => $transaction,
            'refund' => $transaction->getOrderTransactionRefunds()->first(),
            'paymentLinkUrl' => 'link-to-payment',
            'design_url' => 'link-to-payment',
            'cart_url' => 'link-to-payment',
            'catalog_url' => 'link-to-payment',
            'store_name' => $storeName,
        ];

        $sendEmail = $request->get('send', false);
        if ($sendEmail) {
            $email = new TemplatedEmail();
            $email->from(new Address(StoreConfigEnum::SALES_EMAIL, $storeName));
            $email->subject("Test Email #" . $order->getOrderId());
            $email->to($emailAddress);
            $email->cc(new Address(StoreConfigEnum::SALES_EMAIL, $storeName));
            $email->htmlTemplate($template)->context($params);
            $mailer->send($email);
        }

        return $this->render($template, $params);
    }

    #[Route('/update-variants/postions/ysp', name: 'update_variants_postions')]
    public function executeCommand(EntityManagerInterface $entityManager): Response
    {
        $positions = Product::VARIANTS;

        foreach ($positions as $name => $position) {
            $numberOfRecordUpdated = $entityManager->getRepository(Product::class)->updatePosition($name, $position);
            dump($numberOfRecordUpdated . '-' . $name);
        }
        dd('ok' . '-' . $numberOfRecordUpdated);
    }

    #[Route('/update-prices', name: 'update_prices')]
    public function updatePrices(EntityManagerInterface $entityManager, PriceChartHelper $priceChartHelper): Response
    {
        $productType = $entityManager->getRepository(ProductType::class)->findOneBy(['id' => '1']);
        $data = $priceChartHelper::priceChart(productType: $productType, dataOnly: false);

        $productType->setCustomPricing($data['customSizeResult']);
        $productType->setPricing($data['defaultSizeResult']);
        $entityManager->persist($productType);
        $entityManager->flush();
        dd($productType);

        $product = $entityManager->getRepository(Product::class)->findOneBy(['sku' => 'CUSTOMIZABLE']);
        $product->setPricing($data['result']);

        foreach ($product->getVariants() as $key => $variant) {
            $variant->setPricing($data['result_array'][$variant->getName()]);
        }
        $entityManager->persist($variant);
        // $entityManager->flush();
        dd('ok');
    }

    #[Route(path: '/test-store', name: 'test-store')]
    public function testStore(
        Request                $request,
        StoreRepository $storeRepository
    ) {
        $host = $request->getHost();
        $store = $storeRepository->getStoreByHost($host);
        dd($store, $host);
    }

    #[Route(path: '/test-review-email', name: 'test-review-email')]
    public function testReviewEmail(
        Request                $request,
        EntityManagerInterface $entityManager,
        MailerInterface        $mailer
    ) {
        $orderId = $request->get('orderId');
        $email = $request->get('email');
        $type = $request->get('type');
        $date = new \DateTime();

        if (!$orderId || !$email || !$type) {
            return $this->json(['status' => 'Invalid parameters']);
        }

        $order = $entityManager->getRepository(Order::class)->findByOrderId($orderId);

        if (!$order) {
            return $this->json(['status' => 'Order not found', 'date' => $date->format('Y-m-d')]);
        }

        switch ($type) {
            case 'google':
                $this->sendReviewEmail(
                    $order,
                    $email,
                    "Leave a Google Review, Receive 5% Off Your Order!",
                    'emails/order_leave_a_review.html.twig',
                    $mailer
                );
                break;
            case 'photo':
                $this->sendReviewEmail(
                    $order,
                    $email,
                    "Share Your Order Photos, Receive 5% in YSP Rewards!",
                    'emails/review/photo_review.html.twig',
                    $mailer
                );
                break;
            case 'video':
                $this->sendReviewEmail(
                    $order,
                    $email,
                    "Share a Video Review, Receive 5% Off!",
                    'emails/review/video_review.html.twig',
                    $mailer
                );
                break;
            default:
                $this->sendReviewEmail(
                    $order,
                    $email,
                    "Leave a Google Review, Receive 5% Off Your Order!",
                    'emails/order_leave_a_review.html.twig',
                    $mailer
                );
                break;
        }

        return $this->json(['status' => 'Email sent successfully!', 'date' => $date->format('Y-m-d')]);
    }

    private function sendReviewEmail(Order $order, $emailAddress, string $subject, string $template, $mailer): void
    {
        $storeName = $this->storeInfoService->getStoreName();
        $email = (new TemplatedEmail())
            ->from(new Address(StoreConfigEnum::SALES_EMAIL, $storeName))
            // ->cc(new Address(StoreConfigEnum::SALES_EMAIL, $storeName))
            ->to($emailAddress)
            ->subject($subject)
            ->htmlTemplate($template)
            ->context([
                'order' => $order,
            ]);

        $mailer->send($email);
    }

    #[Route(path: '/update-yard-letters-variant', name: 'update-yard-letters-variant')]
    public function updatePrePackedVariant(Request $request, ProductRepository $productRepository)
    {
        $variant = $request->get('variant');
        if (!$variant) {
            return $this->json([
                'status' => 'failed',
                'message' => 'No Variant provided',
            ]);
        }
        $updatedRows = $productRepository->updatePrePackedVariant($variant);
        if ($updatedRows > 0) {
            return $this->json([
                'status' => 'ok',
                'message' => 'Variant updated successfully',
            ]);
        } else {
            return $this->json([
                'status' => 'failed',
                'message' => 'No matching products found to update',
            ]);
        }
    }

    #[Route(path: '/copy-products-to-category', name: 'copy-products-to-category')]
    public function copyProductstoCategory(Request $request, EntityManagerInterface $entityManager)
    {
        $categorySlug = $request->get('slug');
        $targetCategorySlug = $request->get('target_slug');
        $store = $entityManager->getRepository(Store::class)->findOneBy(['shortName' => 'YSP']);
        $category = $entityManager->getRepository(Category::class)->findOneBy(['slug' => $categorySlug]);
        $targetCategory = $entityManager->getRepository(Category::class)->findOneBy(['slug' => $targetCategorySlug]);

        if (!$category || !$targetCategory) {
            return $this->json([
                'status' => 'failed',
                'message' => 'Category not found',
            ]);
        }

        $products = $entityManager->getRepository(Product::class)->findByCategory($category, $store)->getResult();

        foreach ($products as $product) {
            if (!$targetCategory->getProducts()->contains($product)) {
                $targetCategory->addProduct($product);
            }
        }

        $entityManager->flush();

        return $this->json([
            'status' => 'ok',
            'message' => 'Products copied successfully',
        ]);
    }

    #[Route('/ups/time-in-transit')]
    public function timeInTransit(UpsTimeInTransitService $ups, UpsServiceFilter $upsServiceFilter, ShippingChartHelper $shippingChartHelper): Response
    {
        ini_set('max_execution_time', 300);

        $timeInTransitPayload = new TimeInTransitPayload(
            originCountryCode: 'US',
            originPostalCode: '77479',
            originStateProvince: 'TX',
            originCityName: 'Sugar Land',
            destinationCountryCode: 'US',
            destinationStateProvince: 'CA',
            destinationPostalCode: '95131',
            destinationCityName: 'San Jose'
        );

        $daysInTransit = $ups->retrieveDaysInTransit($timeInTransitPayload);

        $shipBy = $shippingChartHelper->calculateShipByDate(new \DateTime('2025-04-20'), $daysInTransit);

        return $this->json([
            'daysInTransit' => $daysInTransit,
            'shipBy' => $shipBy,
            'currentDate' => new \DateTime(),
        ]);
    }

    #[Route('/sync-delivery-date', name: 'sync-delivery-date')]
    public function syncDeliveryDate(Request $request, OrderDeliveryDateService $orderDeliveryDateService, EntityManagerInterface $entityManager): Response
    {

        $order = $entityManager->getRepository(Order::class)->findOneBy([
            'orderId' => $request->get('orderId') ?: '2504389017'
        ]);

        // $orderDeliveryDateService->sync($order);

        $newShippingDate = $orderDeliveryDateService->getNewShippingDate($order);
        dd($newShippingDate);
        return $this->json(['status' => 'success', 'newShippingDate' => $newShippingDate]);
    }

    #[Route('/update-sort-index', name: 'admin_update_sort_index', methods: ['GET'])]
    public function updateSortIndex(EntityManagerInterface $entityManager): Response
    {
        $repository = $entityManager->getRepository(WarehouseShipByList::class);
        $lists = $repository->findBy([], ['shipBy' => 'ASC']);

        foreach ($lists as $list) {
            $list->setSortIndex($list->getId());
            $entityManager->persist($list);
        }

        $entityManager->flush();

        return new Response('SortIndex updated successfully for all records!');
    }

    #[Route('/run-wholeseller-migration', name: 'run_wholeseller_migration')]
    public function migrate(): Response
    {
        $users = $this->em->getRepository(AppUser::class)
            ->createQueryBuilder('u')
            ->where('u.wholeSellerImageFile IS NOT NULL')
            ->andWhere('u.wholeSellerImageFile != :empty')
            ->setParameter('empty', '')
            ->getQuery()
            ->getResult();

        $count = 0;

        foreach ($users as $user) {

            $wholeSeller = $this->em->getRepository(WholeSeller::class)
                ->findOneBy(['appUser' => $user]);

            if (!$wholeSeller) {
                $wholeSeller = new WholeSeller();
                $wholeSeller->setAppUser($user);
            }

            $wholeSeller->setAddress($user->getAddress());
            $wholeSeller->setWholeSellerImageFile($user->getWholeSellerImageFile());

            $this->em->persist($wholeSeller);
            $count++;
        }

        $this->em->flush();

        return new Response("
            <h3>Migration Completed!</h3>
            <p><strong>$count</strong> WholeSeller records created/updated.</p>
        ");
    }

    #[Route('/test-pdf', name: 'test_pdf')]
    public function testPdf(
        Request $request,
        ProofTemplateRepository $proofTemplateRepository,
        OrderRepository $orderRepository,
        AutoGeneratedProofService $proofService
    ): Response {
        $orderId = $request->query->get('orderId');
        $withTemplate = $request->query->get('withTemplate');
        $withCustomerDesign = $request->query->get('withCustomerDesign', false);

        if (!$orderId) {
            throw $this->createNotFoundException('OrderID not found');
        }

        $order = $orderRepository->findByOrderId($orderId);
        if (!$order) {
            throw $this->createNotFoundException('Order not found');
        }

        $mode = $request->query->get('mode', 'html');
        $debug = (bool)$request->query->get('debug', false);

        // Only load HTML for debug mode (to analyze it)
        $html = null;
        if ($debug) {
            if ($withCustomerDesign) {
                $proofTemplates = [];
            } elseif ($withTemplate === '1' || $withTemplate === null) {
                $proofTemplates = $proofTemplateRepository->fetchAll();
            } else {
                $proofTemplates = [];
            }

            $html = $this->renderView('admin/order/auto-generated-proof/index.html.twig', [
                'order' => $order,
                'proofTemplates' => $proofTemplates,
                'withCustomerDesign' => $withCustomerDesign,
            ]);
        }

        /**
         * ============================================================
         * DEBUG MODE: FIND EXACT CAUSES OF DOMPDF FAILURE
         * ============================================================
         */
        if ($debug) {
            //----------------------------------------------------------
            // 1. Extract <img src="">
            //----------------------------------------------------------
            preg_match_all('/<img[^>]+src=["\']([^"\']+)["\']/i', $html, $matches);
            $imgTags = $matches[1] ?? [];

            $imgReport = [];
            foreach ($imgTags as $url) {
                $status = 'UNKNOWN';
                $mime = null;
                $sizeKB = null;

                try {
                    $headers = @get_headers($url, 1);
                    $ok = $headers && str_contains($headers[0], '200');

                    if ($ok) {
                        $status = "OK";
                        $mime = $headers['Content-Type'] ?? null;

                        if (isset($headers['Content-Length'])) {
                            $sizeKB = round($headers['Content-Length'] / 1024, 2);
                        }
                    } else {
                        $status = "BROKEN";
                    }
                } catch (\Throwable $e) {
                    $status = "ERROR";
                }

                $imgReport[] = [
                    'url' => $url,
                    'status' => $status,
                    'mime' => $mime,
                    'size_kb' => $sizeKB,
                ];
            }

            //----------------------------------------------------------
            // 2. Extract CSS background: url(...)
            //----------------------------------------------------------
            preg_match_all('/url\(["\']?([^"\')]+)["\']?\)/i', $html, $cssMatches);
            $cssImages = $cssMatches[1] ?? [];

            //----------------------------------------------------------
            // 3. Extract Base64 images & their sizes
            //----------------------------------------------------------
            preg_match_all('/data:image\/[^;]+;base64,([^"]+)/i', $html, $b64Matches);

            $base64Sizes = [];
            foreach ($b64Matches[1] ?? [] as $raw) {
                $data = base64_decode($raw, true);
                if ($data) {
                    $base64Sizes[] = round(strlen($data) / 1024, 2); // KB
                }
            }

            //----------------------------------------------------------
            // 4. Detect Unsupported CSS
            //----------------------------------------------------------
            $unsupportedCssFound = [];
            $unsupportedRules = [
                'transform',
                'filter',
                'backdrop-filter',
                'flex',
                'grid',
                'calc',
                'position:\s*fixed',
                'box-shadow',
            ];

            foreach ($unsupportedRules as $rule) {
                if (preg_match('/' . $rule . '/i', $html)) {
                    $unsupportedCssFound[] = $rule;
                }
            }

            //----------------------------------------------------------
            // 5. Test Runtime Render with AutoGeneratedProofService
            //----------------------------------------------------------
            $start = microtime(true);
            $renderError = null;
            $pageCount = null;
            $pdfSize = 0;

            try {
                ini_set('memory_limit', '1024M');
                ini_set('max_execution_time', 300);
                
                // Use the actual service to generate PDF
                $pdfOutput = $proofService->generatePdf($order, $withTemplate, $withCustomerDesign);
                $pdfSize = strlen($pdfOutput);
                
                // Estimate page count from PDF size (rough approximation)
                // Average ~50-100KB per page depending on images
                $pageCount = 'estimate: ' . max(1, round($pdfSize / 70000));
                
            } catch (\Throwable $e) {
                $renderError = $e->getMessage();
            }

            $renderTime = round((microtime(true) - $start) * 1000, 2);

            //----------------------------------------------------------
            // 6. System Information
            //----------------------------------------------------------
            $systemInfo = [
                'php_version' => PHP_VERSION,
                'symfony_env' => ($_ENV['APP_ENV'] ?? 'unknown'),
                'memory_limit' => ini_get('memory_limit'),
                'max_execution_time' => ini_get('max_execution_time'),
                'imagick' => extension_loaded('imagick') ? [
                    'installed' => true,
                    'version' => \Imagick::getVersion()['versionString'] ?? null,
                    'supported_formats' => (new \Imagick())->queryFormats(),
                ] : [
                    'installed' => false,
                    'version' => null,
                    'supported_formats' => [],
                ],

                'gd' => extension_loaded('gd') ? [
                    'installed' => true,
                    'version' => gd_info()['GD Version'] ?? null,
                    'supported_types' => [
                        'jpeg' => gd_info()['JPEG Support'] ?? false,
                        'png'  => gd_info()['PNG Support'] ?? false,
                        'webp' => gd_info()['WebP Support'] ?? false,
                        'bmp'  => gd_info()['BMP Support'] ?? false,
                        'gif'  => gd_info()['GIF Read Support'] ?? false,
                    ],
                ] : [
                    'installed' => false,
                    'version' => null,
                    'supported_types' => [],
                ],
            ];

            //----------------------------------------------------------
            // RETURN DEBUG
            //----------------------------------------------------------
            return new JsonResponse([
                'success' => true,
                'html_length_bytes' => strlen($html),
                'image_tags' => [
                    'count' => count($imgReport),
                    'items' => $imgReport,
                ],
                'css_background_urls' => [
                    'count' => count($cssImages),
                    'items' => $cssImages,
                ],
                'base64_images' => [
                    'count' => count($base64Sizes),
                    'sizes_kb' => $base64Sizes,
                    'total_kb' => array_sum($base64Sizes),
                ],
                'unsupported_css' => $unsupportedCssFound,
                'dompdf' => [
                    'page_count' => $pageCount,
                    'render_time_ms' => $renderTime,
                    'pdf_size_kb' => isset($pdfSize) ? round($pdfSize / 1024, 2) : null,
                    'error' => $renderError,
                    'temp_dir' => sys_get_temp_dir(),
                ],
                'system' => $systemInfo,
            ]);
        }

        /**
         * NORMAL HTML MODE - Uses AutoGeneratedProofService (same as PDF)
         */
        if ($mode === 'html') {
            ini_set('memory_limit', '1024M');
            ini_set('max_execution_time', 300);
            
            try {
                // Generate HTML through the service (same way as PDF)
                // We'll render the view the same way the service does
                if ($withCustomerDesign) {
                    $proofTemplates = [];
                } elseif ($withTemplate === '1' || $withTemplate === null) {
                    $proofTemplates = $proofTemplateRepository->fetchAll();
                } else {
                    $proofTemplates = [];
                }

                // Apply the same transformations the service does
                if ($withCustomerDesign) {
                    $proofService->convertImagesToBase64($order);
                }

                $html = $this->renderView('admin/order/auto-generated-proof/index.html.twig', [
                    'order' => $order,
                    'proofTemplates' => $proofTemplates,
                    'withCustomerDesign' => $withCustomerDesign,
                ]);
                
                return new Response($html);
                
            } catch (\Throwable $e) {
                return new Response(
                    '<h1>HTML Generation Failed</h1>' .
                    '<pre>Error: ' . $e->getMessage() . '</pre>',
                    Response::HTTP_INTERNAL_SERVER_ERROR
                );
            }
        }

        /**
         * NORMAL PDF MODE - Using AutoGeneratedProofService
         */
        ini_set('memory_limit', '1024M');
        ini_set('max_execution_time', 300);
        set_time_limit(300);

        try {
            $pdfOutput = $proofService->generatePdf($order, $withTemplate, $withCustomerDesign);
            
            return new Response($pdfOutput, 200, [
                'Content-Type' => 'application/pdf',
                'Content-Disposition' => 'inline; filename="test.pdf"',
            ]);
            
        } catch (\Throwable $e) {
            return new Response(
                '<h1>PDF Generation Failed</h1>' .
                '<pre>' .
                'Error: ' . $e->getMessage() . "\n\n" .
                'File: ' . $e->getFile() . ':' . $e->getLine() . "\n\n" .
                'Trace:' . "\n" . $e->getTraceAsString() .
                '</pre>',
                Response::HTTP_INTERNAL_SERVER_ERROR
            );
        }
    }
}
